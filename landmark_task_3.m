function[] = landmark_task_1(subj_id, run, instruct)%function[] = landmark_task_1(subj_id, run, instruct)% todo% - think about priority/rush% - viewing distance in TMS room: 107 cm%ss- changed the length of the offset of each stimulus.  rather than being 1 and 2 degrees off,%changed to .5 and 1 degree off. changed backround to gray. changed number of neutrals%to 20 and the number of offset stimuli to 16 (8 to right, 8 to left).rand_init = sum(100*clock);rand('state',rand_init); %randomize the seedlog_fname = sprintf('%s_r%i.txt', subj_id, run);%ss_073008_r1.txtmat_fname = sprintf('%s_r%i.mat', subj_id, run);%ss_073008_r1.mattm_fname = sprintf('%s_r%i_timing.txt', subj_id, run);%ss_073008_r1_timing.txt%run #, trial #, instruct, stim_shift_pix, stim_width_pix, response, %correct, RT. %instruct = 1, "Which is longer?"; instruct =2, "Which is shorter?"%stim_shift_pix < 0, shift to left. stim_shift_pix > 0, shift to the right. stim_shift_pix = 0, symmetrical%response = 1, pressed the right button. response = 2, pressed the left button. response = -1, did not respond.%correct =1, correct response. correct = 0, incorrect response. correct = -1, no right/wrong answer%RT = 0 when subjects do not respond to stimulusbehav = zeros(0,8); %initializes the behavioral matrix%timing = GetSecs, trial #, trial start time, trigger reset time, fix start time,%stim start time, zap time, mask start time, response time, trial end timetiming = zeros(0,10);%initializes a time matrix%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%stimulus parametersnum_trials = 36;fix_dur = 1; % amount of time (in sec) that the fixation point is on at beginning of trialstim_dur = .20; % amount of time (in sec) that the transected stimulus is oniti_dur = 4; % amount of time (in sec) between offset of transected stimulus and beginning of trialbutton_right = kbname('k'); %this is the "," (44) button on the keyboardbutton_left = kbname('j'); %this is the "." (66) button on the keyboardres_x = 800;%resolution of monitor in x direction TMS roomres_y = 600;%resolution of monitor in y direction TMS room%res_x = 1280;%resolution of monitor in x direction for laptop%res_y = 854;%resolution of monitor in y direction for laptop%sz = [32 21.5];%sz of sreen in cm for laptopsz = [40 30];%sz of sreen in cm. TMS room screen.vdist = 62;%distance from screen in cm approx for TMS room.%vdist = 32;%distance from screen in cm approx for laptop.TMS_on = 0;% 0= not running TMS study. 1= running TMS studyzap_interval = 0.1;% set to 100 ms%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%VisAng takes the screen resolution, screen size, and viewing distance and calculates%the pixels per degree or degrees per pixel. returns two values per variable: pixels per%degree in the x direction and pixels per degree in the y direction (or the same for%degrees per pixel)[ppd dpp] = VisAng([res_x res_y],sz,vdist);%ppd = pixels per degree, dpp = degrees per pixel% 1 x num_trials vector, with each value being the size% (in degrees of visual angle) of the rightwards shift% for a given trial stim_shift_deg_ordered = [ones(1,(4*num_trials/36))*.5 ... % shift right by .5 deg 			      ones(1,(4*num_trials/36))*1 ... % shift right by 1 deg 			      ones(1,(4*num_trials/36))*-.5 ... % shift left by .5 deg 			      ones(1,(4*num_trials/36))*-1 ... % shift left by 1 deg  			      zeros(1,(20*num_trials/36))]; % symmetrical, i.e. no shift				  % stim_shift_deg_ordered = [ones(1,num_trials/6)*0 ... % shift right by 1 deg% 			      ones(1,num_trials/6)*0 ... % shift right by 2 deg% 			      ones(1a,num_trials/6)*0 ... % shift left by 1 deg% 			      ones(1,num_trials/6)*0 ... % shift left by 2 deg%  			      ones(1,num_trials/3)*0]; % symmetrical, i.e. no shift				  				  shuf_idx = randperm(num_trials);%stores the new random ordering of the trialsstim_shift_deg = stim_shift_deg_ordered(shuf_idx);%randomizes using shuf_idxstim_shift_pix = round(stim_shift_deg * ppd(1));%we only take ppd 1 because it's the x value, and we%are only shifting stimuli in the x direction (i.e., horizontally)% 1 x num_trials vector, with each value being the length% (in degrees of visual angle) of the transected line% for a given trial% in most studies, the longest and shortest lengths are used only with the % bisected lines, and and middle lengths are divided evenly between the right and left conditions. stim_width_deg_ordered = [ones(1,(2*num_trials/36))*21 ones(1,(2*num_trials/36))*22 ... % line length = 21,22 degs  			      ones(1,(2*num_trials/36))*21 ones(1,(2*num_trials/36))*22 ...% line length = 21,22 degs 			      ones(1,(2*num_trials/36))*21 ones(1,(2*num_trials/36))*22 ... % line length = 21,22 degs 			      ones(1,(2*num_trials/36))*21 ones(1,(2*num_trials/36))*22 ...% line length = 21,22 degs 				  ones(1,(10*num_trials/36))*20 ones(1,(10*num_trials/36))*23 ...% line length = 20, 23 degs 			     ];% stim_width_deg_ordered = [ones(1,num_trials/12)*21 ones(1,num_trials/12)*21 ... % line length = 21,22 degs % 			      ones(1,num_trials/12)*21 ones(1,num_trials/12)*21 ...% line length = 21,22 degs% 			      ones(1,num_trials/12)*21 ones(1,num_trials/12)*21 ... % line length = 21,22 degs% 			      ones(1,num_trials/12)*21 ones(1,num_trials/12)*21 ...% line length = 21,22 degs% 				  ones(1,num_trials/6)*21 ones(1,num_trials/6)*21 ...% line length = 20, 23 degs% 			     ];			  stim_width_deg = stim_width_deg_ordered(shuf_idx);stim_width_pix = round(stim_width_deg * ppd(1));stim_bar_height = round(2*ppd(2));%height of the transecting bar (2 degrees of visual angle)mask_bar_height = round(10*ppd(2));stimThickness = round(0.1*ppd(2)); % pen thickness of the transected stimulus linemaskThickness = round(0.2*ppd(2)); % pen thickness of the maskmask_width_pix = round(50*ppd(1));%length of mask linefix_width = 10;fix_height = 10;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%BLACK_INDEX		= 0;WHITE_INDEX = 5;GRAY_INDEX = 10;clut = zeros(256, 3);clut(BLACK_INDEX	+ 1, :) = [0 0 0];clut(WHITE_INDEX	+ 1, :) = [255 255 255];%clut (GRAY_INDEX    + 1, :) = [128 128 128];clut (GRAY_INDEX    + 1, :) = [110 110 110];Bkcolor	= GRAY_INDEX;	% background color %ssp.res = SCREEN(0,'Resolution');%from stephanie's codep.res.pixelSize = 8;%p.res = NearestResolution(0,res_x,res_y,85,8);%this is from keith's code. sets screen resolution.[w, rect] = SCREEN(0, 'OpenWindow', Bkcolor, [], p.res);	% open main screenw2 = SCREEN(0, 'OpenOffscreenWindow',[],rect);Screen(w, 'SetClut', clut);	% Set the CLUT (color look-up table) with the clut that was created up aboveHideCursor;	% Hide the mouse cursorcenter = [rect(3) rect(4)]/2;	% center of screen (pixel coordinates)p.frame_rate=SCREEN(w,'FrameRate');	% frames per secondfix_cord = [center(1) center(2)];SCREEN(w,'TextSize',20);%SCREEN(w,'DrawText','+', fix_cord(1),fix_cord(2), BLACK_INDEX);	% fixation crossdraw_pnline(w,center,fix_width,0,WHITE_INDEX,stimThickness, fix_height);%describescreen(0)% we have hardcoded this text since it only gets used for centering, and % since we don't expect the question to change. if it does, change this length. % we're ignoring the fact that there are two questions ('longer' and 'shorter') % and that their length is different by 1% % pair of x,y coordinates for the text location (in the middle of the screen, % at the very beginning of the run)SCREEN(w,'TextSize',16);txtloc_mid = [center(1) - SCREEN(w,'TextWidth','Which side is shorter?')/2, ... % x	          center(2) + 40]; % y% the location of the question (e.g. 'which side is longer?') at the top % of the screen, displayed throughout the rest of the runSCREEN(w,'TextSize',16);txtloc_top = [center(1) - SCREEN(w,'TextWidth','Which side is shorter?')/2, ... % x     	       center(2) - 200]; % y% tell the subject what to do for the rest of this rundisplay_question(w,WHITE_INDEX,instruct,txtloc_mid); FlushEvents('keydown');kbwait;% just testing rectangles% SCREEN(w,'FillRect',WHITE_INDEX,[0 0 500 500]);% blank the screen%SCREEN(w,'FillRect',Bkcolor);% for each trial, a fixation point comes on for 1 s, followed by a stimulus for 200 ms, %followed by a mask that stays on until subjects respond. the response period is %built into the 3 sec intertrial interval.if TMS_on	IOCard_nidaq(1,0,0);%resets the trigger. resetting here because it takes some time the first time it is reset.	%disp('resetting');end for t = 1:num_trials	%create full screen of random noise for the mask (>= .5 causes 1's and 0's)	%we do this beforehand because it takes about 600 ms to do next two steps.	mask_mat = (rand(rect(4), rect(3)) >= .50) * WHITE_INDEX;	% mask_mat = ones(rect(3),rect(4))*.5;	% size(mask_mat)	SCREEN(w2, 'PutImage', mask_mat); %copy the random mask to the back buffer		trial_start_time = GetSecs;		fix_drawn = 0;	fix_start_time = trial_start_time;	fix_end_time   = fix_start_time + fix_dur;		stim_drawn = 0;	stim_start_time = fix_end_time;	stim_end_time   = stim_start_time + stim_dur;		zapped = 0;	zap_start_time = stim_start_time + zap_interval;% define when the TMS pulse will occur		mask_drawn = 0;	mask_start_time = stim_end_time;	trial_end_time = trial_start_time + fix_dur + stim_dur + iti_dur;		check_resp = 0;	button_press = 0;%this shouldn't be necessary, but we are resetting at the beginning	%of every trial just in case. 	% while loop for the duration of the trial	SCREEN(w,'FillRect',Bkcolor);	% display_question(w,WHITE_INDEX,instruct,txtloc_top);		% set analog output (to trigger) to 0	if TMS_on		actual_trigger_reset_time = GetSecs;		IOCard_nidaq(1,0,0);%resets the trigger		%disp('resetting');	else 		actual_trigger_reset_time = -1;%if the TMS machine is not on, then we are setting 		actual_zap_time = -1;%these to a negative number so we know that they are not being recorded.	end		while GetSecs < trial_end_time%%start of main while loop for one trial				% draw fixation cross for 1000ms		if GetSecs > fix_start_time & GetSecs < fix_end_time & fix_drawn==0			actual_fix_start_time = GetSecs;			SCREEN(w,'TextSize',20);			%SCREEN(w,'DrawText','+', fix_cord(1),fix_cord(2), BLACK_INDEX);	% fixation cross 			draw_pnline(w,center,fix_width,0,WHITE_INDEX,stimThickness, fix_height);			fix_drawn = 1;		end % fixation cross			% draw stimulus for 200ms		if GetSecs > stim_start_time & GetSecs < stim_end_time & stim_drawn==0			SCREEN(w,'FillRect',Bkcolor);			% display_question(w,WHITE_INDEX,instruct,txtloc_top);			actual_stim_start_time = GetSecs;			draw_pnline(w,center,stim_width_pix(t),stim_shift_pix(t),WHITE_INDEX,stimThickness, stim_bar_height);% draw a pseudoneglect stimulus 			stim_drawn = 1;			check_resp = 1;		end % stimulus			if TMS_on & GetSecs > zap_start_time & zapped == 0 			actual_zap_time = GetSecs;			IOCard_nidaq(1,0,2047);	% send trigger pulse			zapped = 1;			%disp('triggering');		end				if GetSecs > mask_start_time & GetSecs < trial_end_time & mask_drawn==0			%SCREEN(w,'FillRect',Bkcolor); %we may want to blank the screen before			%presenting the mask, but this may not be necessary since the maks will			%overright the stimulus anyway.			% draw the mask			actual_mask_start_time = GetSecs;			%draw_pnline(w,center,mask_width_pix,0,BLACK_INDEX,maskThickness, mask_bar_height);			SCREEN('CopyWindow',w2,w); %copy from back to front buffer, so mask is visible			mask_drawn = 1;			% wait for keyboard input and hide the mask		end % mask and ITI				if GetSecs > mask_start_time & check_resp == 1			[keyIsDown, actual_response_time, keycode] = kbcheck; %check response			if find(keycode(button_right))%pressed the right button				button_press = 1;				check_resp=0;				SCREEN(w,'FillRect',Bkcolor);				% display_question(w,WHITE_INDEX,instruct,txtloc_top)				RT = actual_response_time - stim_start_time;				if instruct == 1 & stim_shift_pix(t) < 0, correct = 0;%what is longer & stimulus is to the left				elseif instruct == 1 & stim_shift_pix(t) > 0, correct = 1;%what is longer & stimulus is to the right				elseif instruct == 2 & stim_shift_pix(t) < 0, correct = 1;%what is shorter & stimulus is to the left				elseif instruct == 2 & stim_shift_pix(t) > 0, correct = 0;%what is shorter & stimulus is to the right				elseif stim_shift_pix(t) == 0, correct = -1; % no shift, no right or wrong answer				else error('Unknown condition'); end				% add a row to the BEHAV matrix:				% run #, trial #, instruct, stim_shift_pix, stim_width_pix, response, 				% correctness, RT.				behav(end+1,:) = [run, t, instruct, stim_shift_pix(t), stim_width_pix(t) ...								  button_press, correct, RT];			elseif find(keycode(button_left))%pressed the left button				button_press = 2;				check_resp=0; %stop checking				SCREEN(w,'FillRect',Bkcolor);				% display_question(w,WHITE_INDEX,instruct,txtloc_top);				RT = actual_response_time - stim_start_time;				if instruct == 1 & stim_shift_pix(t) < 0, correct = 1;%what is longer & stimulus is to the left				elseif instruct == 1 & stim_shift_pix(t) > 0, correct = 0;%what is longer & stimulus is to the right				elseif instruct == 2 & stim_shift_pix(t) < 0, correct = 0;%what is shorter & stimulus is to the left				elseif instruct == 2 & stim_shift_pix(t) > 0, correct = 1;%what is shorter & stimulus is to the right				elseif stim_shift_pix(t) == 0, correct = -1; % no shift, no right or wrong answer				else error('Unknown condition'); end				% add a row to the BEHAV matrix:				% run #, trial #, instruct, stim_shift_pix, stim_width_pix, response, 				% correctness, RT.				behav(end+1,:) = [run, t, instruct, stim_shift_pix(t), stim_width_pix(t) ...								  button_press, correct, RT];			end		end			end%end while loop	actual_trial_end_time = GetSecs;	if check_resp == 1%during when we are looking for a response and subjects have not		%yet pressed a button this trial		button_press = -1;%they didn't respond (no press)		correct = 0; % count no-press as wrong		RT = -1;%count reaction time as negative		actual_response_time = -1;		% they didn't press either of the allowed keys		%		% add a row to the BEHAV matrix:		% run #, trial #, instruct, stim_shift_pix, stim_width_pix, response, 		% correctness, RT.		behav(end+1,:) = [run, t, instruct, stim_shift_pix(t), stim_width_pix(t) ...								  button_press, correct, RT];	end	timing(end+1,:) = [run, t, trial_start_time, actual_trigger_reset_time, actual_fix_start_time, ...						actual_stim_start_time, actual_zap_time, actual_mask_start_time, actual_response_time, ...						actual_trial_end_time];	end%end for loop% save as ascii tab-delimited (i.e. tabs between each columns, % so you can open/paste it in excel%% BEHAVE = run #, trial #, instruct, stim_shift_pix, stim_width_pix, response, % correctness, RT.save(log_fname,'behav','-ascii','-tabs');save(tm_fname,'timing','-ascii','-tabs');save(mat_fname);SCREEN('CloseAll');ShowCursor;